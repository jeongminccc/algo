# Dijkstra's Algorithm

최단거리를 구할때 사용하는 대표적인 알고리즘이다. 그래프의 어떤 정점 하나를 시작점으로 선택 후, 나머지 정점들로의 최단거리를 모두 구한다. 정점 개수가 V, 간선 개수가 E일때 최적화를 거친 시간복잡도는 __O(ElogV)__ 이다.  

- 그래프는 무향이거나 유향인데 대체로 유향인 경우가 많고, 간선마다 이동거리가 존재한다.
- 모든 거리값이 음수가 아닐때만 사용할 수 있다.  
> 거리 값 중 음수가 있다면 벨만 포드 알고리즘을 사용해야 한다.

## 최단경로를 구하는 방식
1. 아직 방문하지 않은 정점중 가장 거리가 짧은 정점 하나를 선택하여 방문한다. 
2. 해당 정점에서 인접하고 아직 방문하지 않은 정점들의 거리를 갱신한다. 

> 처음에는 자신과의 거리는 0, 나머지 모든 정점과의 거리는 무한으로 두고 시작한다.  

## 증명 
아직 방문하지 않은 정점들 중 가장 dist값이 작은 정점이 u고, 사실 dist[u]는 최단거리보다는 아직 크다고 가정하자.  
이때 u를 방문한다면 dist[u]는 최단거리가 아니게 되고, 따라서 이 알고리즘은 틀리게 된다. 하지만 dist[u]가 최단거리가 아니라고 한다면, u로 갈수 있는 다른 최단 경로가 존재한다는 말이고, u로 최단경로를 통해 갈수 있는 어떤 정점 v가 존재한다고 말할 수 있다. (즉 dist[u] > dist[v] + d[v][u]인 v가 존재)  
그런데 우리는 최단경로를 구할때, 방문하지 않은 정점중 가장 dist값이 작은 정점 u라고 했으므로, v는 방문한 상태인것이 자명하다.  
따라서 v를 방문했다면, dist[u]는 이미 최단경로인 dist[v] + d[v][u]로 갱신이 되었을 것이고, dist[u]는 최단거리가 된다.

## 구현
만약 우리가 방문하지 않은 정점중 dist값이 가장 작은 정점을 브루트 포스로 찾게된다면, 매번 O(V), V-1번의 루프가 실행되어 시간복잡도는 O(V^2)가 된다.  

따라서 우선순위 큐를 활용하여 구현한다.  
먼저 최소 힙을 하나 만든 후, 정점 u를 방문해서 인접한 정점 v의 거리를 갱신할 때마다 최소 힙에 (dist[v], v) 쌍을 넣는다. 
즉, dist값이 작으면 작을수록 우선순위 큐에서 먼저 나오게 되고, dist값이 제일 작은 걸 뽑은 뒤 두번째 인자인 정점 번호를 사용하면된다.  
이때, 같은 v정점에 대한 다른 dist값들이 우선순위 큐에 저장되 있는 경우가 있는데, 이때는 제일 먼저나오는 dist, v 쌍이 최단거리이므로 꺼낸 정점 v가 이미 방문한 곳이라면 무시 후 다음 top를 꺼내면 된다.    

이런 방식으로 구현한다면 한 정점에 최대한 많은 갱신이 이루어 진다고 가정해도 V^2번 갱신이 이루어 져서, 우선순위 큐에 V^2개의 정보가 들어있다고 해도 우선순위 큐는 원래 연산에 O(logN)의 시간이 들기 때문에 O(log(V^2)) = O(2logV) = O(logV).  
즉 최대 O(E)번 우선순위 큐에서 top를 꺼내는 연산 O(logV), 루프 전체를 통틀어서 인접한 정점으로의 거리를 갱신하는 부분도 최대 O(E)번 이루어질 것이므로 총 시간복잡도는 O(ElogV)가 된다.  
> 만약 인접 리스트가 아닌 인접 행렬로 구현했다면 루프마다 O(V)의 시간이 소요되어 총 O(V^2)가 될 것이다.  

### 예외처리
그래프 자체가 연결 그래프가 아니거나 유향 그래프에서 시작점에서 어떤 정점으로 못 갈때는 루프를 꼭 V-1번 돌지 못한다. 중간에 우선순위 큐가 비어버리는 현상이 나타나게 되고 루프가 끝나게 되므로 방문하지 못한 정점들이 생기게 된다.

### code
```cpp
// 다익스트라 알고리즘
   dist[K] = 0; // 시작점으로의 거리는 0
   pq.push(pii(0, K)); // 시작점만 PQ에 넣고 시작
   while(!pq.empty()){ // PQ가 비면 종료
       int curr;
       do{
           curr = pq.top().second;
           pq.pop();
       }while(!pq.empty() && visited[curr]); // curr가 방문한 정점이면 무시
       // 더 이상 방문할 수 있는 정점이 없으면 종료
       if(visited[curr]) break;

       visited[curr] = true; // 방문
       for(auto &p: adj[curr]){
           int next = p.first, d = p.second;
           // 거리가 갱신될 경우 PQ에 새로 넣음
           if(dist[next] > dist[curr] + d){
               dist[next] = dist[curr] + d;
               pq.push(pii(dist[next], next));
           }
       }
   }
```
###
출처 :  https://blog.naver.com/kks227/220796029558
