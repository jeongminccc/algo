# 도시락 데우기
## 문제설명
n개의 도시락을 주문 후, 모두 냉장고에 넣어 두었다. 그 후 데우려는데 전자레인지가 하나밖에 없다는 사실을 깨달았다.  
i번째 도시락을 데우는 데는 m(i)초가 걸리고, 먹는데는 e(i)초가 걸린다.  
나누어 데우기는 불가능 하며, 도시락은 다 데우는 대로 곧장 먹기 시작한다.  
점심을 먹는데 걸리는 시간을 최소화 하자.
- 이런 형태의 스케줄링 문제는 탐욕법 문제의 단골 손님이다.

## 최소화해야 할 값
한 도시락을 먹을때까지 걸리는 시간은 지금까지 데운 모든 도시락을 데우는 시간의 합에 이 도시락을 먹는 시간을 더한 것이다.  
우리는 그중 제일 늦게 다 먹는 도시락에 걸리는 시간을 최소화 하려 한다.  

## 탐욕적 알고리즘의 구상
모든 도시락을 먹는데 같은시간 C가 걸린다고 가정해 보자. 그러면 순서가 어떻던 간에 점심시간의 길이는 C + (m1 + m2 + ... + mi)라는것을 알 수 있다. 마지막에 데우는 도시락을 결국 마지막에 먹게 될 것이므로.  
만약, 먹는데 시간이 오래 걸리는 샤브샤브 도시락이 있다고 가정하면, 이것은 가장 빨리 데우는것이 낫다. 마지막에 데우면 먹는 시간의 차이만큼 길어지지만, 처음에 데우면 다른 도시락을 데우는 사이에 샤브샤브를 먹을 수 있기때문이다. 

## 탐욕적 선택 속성 증명
이 알고리즘의 정당성 또한 지금까지의 탐욕법 증명과 같은 맥락에서 증명할 수 있다.  
도시락의 목록이 주어질 때, 먹는데 가장 오래 걸리는 샤브샤브 도시락을 제일 먼저 데우는 최적해가 반드시 하나는 있음을 보여 주면 된다. 이를 위해 돈까스 도시락을 제일 먼저 데우는 최적해가 존재한다고 가정해보자.  

번호 | 0 | ... | x | x + 1 | ... | n - 1 | 
--- | --- | --- | --- | --- | --- | --- |
도시락 | 돈까스 | ... | 샤브샤브 | ... | ... | ... |

이 최적해에서 둘의 위치를 바꾼 뒤 이것도 최적해가 된다는 것을 보이도록 하자.  
유의할 부분은, 이 둘의 위치를 바꾼다고 해도 x+1번 이후의 도시락들의 입장에선 다를것이 없다는 것이다. 그러니 0번부터 x번까지의 도시락들만 고려해보자.  

| 번호 | 0 | ... | x |
| --- | --- | --- | --- |
| 도시락 | 돈까스 | ... | 샤브샤브 |

이떄 이중 가장 마지막에 식사가 끝나는 도시락은 항상 샤브샤브 이다.  
샤브샤브를 먹는 사람이 식사가 끝나는 시간은 0번부터 x번까지의 도시락을 데우는 시간과 샤브샤브를 먹는데 걸리는 시간의 합이다. 
이제 남은 도시락들의 순서를 자유롭게 바꾼다고 가정하자. 어떤 도시락도 다 먹는데 걸리는 시간이 앞에서 설명한 값을 초과할 순 없다.  
이 순서에서 y번째 도시락은 샤브샤브보다 먹는데에 오래걸리지 않을 것이고, 더 오래 기다려야하는것도 아니므로 앞에서 설명한 값보다 클순 없다.  
따라서 샤브샤브와 돈까스의 순서를 바꾼 답이 최적해 보다 나빠질 수는 없고, 이 답도 최적해라는 것을 알 수 있다.

## 최적 부분 구조 증명
첫 번째 도시락을 정하고 나면 나머지 도시락들을 배치해야 하는데, 이때 각 도시락을 다 먹기까지 걸리는 시간은 첫 번째 도시락을 데우는 시간만큼 지연되지만, 남은 도시락들에 대해서도 가장 늦게 다 먹는 시간을 최소화해서 손해볼 것은 없다. 따라서 매 단계마다 최적의 선택을 해도 상관없다는 사실을 알 수 있다.

## 구현
- 처음에 모든 도시락을 먹는데 걸리는 시간의 역순으로 정렬하기 위해 pair<int,int>를 이용하였다.  
- e[i]의 부호를 뒤집어 넣음으로써 역순 정렬을 좀더 간단하게 구현하였다.  
- 그 다음에는 O(n)시간이 걸리는 간단한 시뮬레이션으로 답을 구할 수 있다. 
- 전체 시간복잡도는 정렬에 걸리는 O(nlgn)이 지배하게 된다.

```cpp
int n, e[MAX_N], m[MAX_N];
int heat(){
// 어느 순서로 데워야 할지를 정한다.
vector<pair<int,int>> order;
for(int i=0; i<n; ++i)
order.push_back(make_pair(-e[i], i));
sort(order.begin(), order.end());
// 해당 순서대로 데워먹는 과정을 시뮬레이션 한다.
int ret = 0, beginEat=0;
for(int i=0; i<n; ++i){
int box = order[i].second;
beginEat += m[box];
ret = max(ret, beginEat + e[box]);
}
return ret;
}
``` 
| ㅇㅇ | --- | ㅇㅇ | ㅇㅇ |
| ㅇㅇ | --- | ㅇㅇ | ㅇㅇ |
