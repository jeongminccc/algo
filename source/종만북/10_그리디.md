# Greedy Algorithm
 
 - 가장 직관적인 알고리즘 설계 패러다임 중 하나.
 'Greedy'는 우리가 원하는 답을 재귀 호출과 똑같이 여러개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 나간다는 점에서 완탐이나 DP와 다를것이 없다.
 그러나 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는 두 방법과는 달리, greedy는 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.

 예를 들어 외판원 문제를 돌이켜 보면,
 DP는 다음에 도착할 수 있는 도시들을 하나하나 검사해 보고, 남은 도시들을 모두 순회하는데 필요한 거리의 합을 최소화하는 답을 찾는다.
 하지만 그리디는 당장 다음 도시까지의 거리만을 최소화 한다. 따라서 아직 방문하지 않은 도시중 가장 가까운 도시로 움직이는 것을 모든 도시를 방문할 때까지 반복하게 된다.
 그리디는 지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않는다.

 당연하게도, 이러한 그리디 알고리즘은 많은 경우 최적해를 찾지 못한다. 따라서 그리디가 사용되는 경우는 크게 두 가지로 나뉘어 지는데,
 1. 그리디를 사용해도 항상 최적해를 구할 수 있는 문제를 만난경우 -> DP보다 수행시간이 훨씬 빠름
 2. 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)을 찾는 것으로 타협할 수 있다.
 그리디는 이럴때 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰임.

 그리디는 프로그래밍 대회에서는 보통 1번용도로만 쓰인다. 근사해를 찾는 문제는 대개 출제 되지 않을 뿐 더러, 이러한 문제가 주어졌다 해도 그리디보다
 조합 탐색이나 메타휴리스틱 알고리즘이 더 좋은 답을 주는 경우가 많기 때문.
 그리디의 개념은 간단하지만, 어떠한 방법을 선택해야 최적해를 구할 수 있는지 알아내기가 어렵다.
 따라서 그리디 연습문제를 풀때는, 알고리즘의 정당성을 증명하는 과정을 빼먹지말고 연습하는 것이 중요.
