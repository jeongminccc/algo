# 비트마스크
## 개요
### 비트마스크의 장점
- 더 빠른 수행 시간
- 더 간결한 코드
- 더 작은 메모리 사용량
- 연관 배열을 배열로 대체 : map<vector<bool>,int>를 int[]로 사용해 나타 낼 수 있음.

### 연산자 우선순위
&, |, ^ 등의 비트 연산자의 우선순위는 == 혹은 != 등의 비교 연산자 보다 낮다.  

```cpp
int c = (6 & 4 == 4);
```

이와 같은 경우 4==4가 먼저 계산되고, 이 결과인 1이 6과 AND되어 c는 0이 된다. 따라서 다음과 같이 표기해야 함.  
```cpp
int d = ((6 & 4) == 4);
```

### 오버플로우
64비트 정수를 비트마스크로 사용할 때 오버플로우 실수를 많이 범한다.  
```cpp
bool isBitSet(unsigned long long a, int b){
    return (a & (1 << b)) > 0; 
}
```
c++에서 1은 부호 있는 32비트 상수로 취급되기 때문에, b가 32 이상이면 오버플로우가 발생한다. 이 를 해결하기 위해서는 1 뒤에 이 상수가 부호 없는 64비트 정수임을 알려주는 접미사 ull을 붙여 주어야 한다.  
- 변수의 모든 비트를 다 쓰고 싶다면 부호 없는 정수형을 쓰자.  

### 시프트 연산
N비트 정수를 N비트 이상 왼쪽으로 시프트한다면, 0이 나와야 할 것 같지만 사실 환경에 따라 다른 결과를 낼 수 도 있다.  

## 비트마스크를 이용한 집합의 구현
N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 된다.  
원소 i가 집합에 속해 있는지 여부는 2^i을 나타내는 비트가 켜져 있는지 여부로 나타낸다.  
> {1, 4, 5, 6, 7, 9} 2^1 + 2^4 + 2^5 + 2^6 + 2^7 + 2^9 = 10 1111 0010 = 754  

### 공집합과 꽉 찬 집합 구하기 
상수 0이 공집합을 나타내고, 크기 20짜리 집합의 꽉 찬 집합은 다음과 같이 나타낼 수 있다.
```cpp
int fullPizza = (1 << 20) - 1;
```
### 원소 추가
해당 비트를 켠다는 뜻이다.
```cpp
toppings |= (1 << p);
```
1을 왼쪽으로 p비트 시프트후 OR연산, 이미 들어가 있을경우에 값이 변하지 않는다.

### 원소의 포함 여부 확인
```cpp
if(toppings & (1 << p)) cout << "pepperoni is in" << endl;
```
- & 연산의 결과값이 0 또는 (1 << p) 라는것에 유의!  

### 원소의 삭제
```cpp
toppings -= (1 << p);
```
하지만 이 코드는 만약 페퍼로니가 토핑목록에 없다면 오류가 발생한다.  
```cpp
toppings &= ~(1 << p);
```
해당 비트만 꺼지고 나머지는 다 켜진 숫자가 된다.

### 원소의 토글
해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜도록 한다.
```cpp
toppings ^= (1 << p);
```

### 두 집합에 대해 연산하기
- 합집합
```cpp int added = (a | b);
```
- 교집합
```cpp int intersection = (a & b);
```
- 차집합
```cpp int removed = (a & -b);
```
- a와 b중 하나에만 포함된 원소들의 집합
```cpp int toggled = (a ^ b);
```
> 집합간의 연산을 이렇게 빠르게 할 수 있다는 것이 비트마스크를 이용한 집합 표현의 큰 장점이다.  

### 집합의 크기 구하기
각 비트를 순회하면서 켜져 있는 비트의 수를 직접 세야한다.
```cpp
int bitCount(int x){
    if(x == 0) return 0;
    return x % 2 + bitCount(x / 2);
}
``` 
> ( gcc/g++에서 __builtin_popcount(toppings) )

### 최소 원소 찾기 
이 연산은 "이 정수의 이진수 표현에서 끝에 붙어 있는 0이 몇개 인가?"의 형태로 지원된다.  
켜져 있는 최 하위 비트의 번호를 반환하게 된다. ( gcc/g++에서 __builtin_ctz(toppings) )  

> 만약 최 하위 비트의 번호 대신 해당 비트를 직접 구하고 싶다면??
```cpp int firstTopping = (toppings & -toppings);
```

### 최소 원소 지우기
```cpp toppings &= (toppings - 1);
```
