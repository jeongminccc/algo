//
//  8_비대칭타일링.cpp
//  algo
//
//  Created by jm on 2020/08/26.
//  Copyright © 2020 jm. All rights reserved.
//

// 2 x n 크기의 직사각형을 2 x 1크기의 타일로 채우려고 한다.
// n이 주어질 때 가능한 비대칭 타일링 방법의 수를 계산해라.

// 지금까지는 1.완탐 2.메모이제이션이었지만, 이러한 문제는 기존에 풀어본 문제의 변형된 형태이므로,
// 직접적으로 풀기보다 좀 더 단순화된 문제의 해법을 이용해서 더 쉽게 풀 수 있는 경우가 있다.
// 전체 타일링의 개수에서 대칭 타일링을 빼서 얻을 수 있다.
// 첫번째 단계는 n이 짝수인 경우와 홀수인 경우를 각각 나눠 보는 것이다.
// n이 홀수인 경우, 타일링 방법이 대칭이기 위해서는 항상 정가운데 있는 세로줄을 세로 타일 하나로 덮여야만 하고, 왼쪽과 오른쪽은 대칭이어야한다.
// n이 짝수인 경우, 정가운데 세로줄 둘을 가로타일로 덮은 경우 / 정확히 정중앙을 기준으로 대칭인경우가 있다.

int asymmetric(int width){
    if(width % 2 == 1)
        return (tiling(width) - tiling(width/2) + MOD) % MOD;
    int ret = tiling(width);
    ret = (ret - tiling(width/2) + MOD) % MOD;
    ret = (ret - tiling(width/2-1) + MOD) % MOD; // MOD를 더하는 이유는 양수인경우를 방지하기위함.
    return ret;
}
// 시간복잡도는 O(n)

// 직접 비대칭 타일링의 수 세기
// 모든 타일링 방법을 만들어 보고 이중 좌우 대칭이 아닌것만을 걸러내면 된다.
// 근데 대칭인지 판단하기 위해서는 과거에 선택한 조각들에 대한 정보들을 모두 전달해야하기 떄문에 힘듦.
// 맨 앞에서 타일링 방법을 만들어나가는것 대신, 양쪽끝에서부터 동시에 만들어 나가는 방법이 있다.

// 양쪽 끝이 대칭인 경우 -> 남은 부분들을 덮는방법을 재귀호출로 찾는다. 이 방법은 좌우 대칭이 아니어야 함. ===> 재귀호출로 해결
// 양쪽 끝이 대칭이 아닌경우 -> 대칭이어도 상관없음. ===> tiling()이용

int cache2[101];
int asymmetric2(int width){
    if(width <= 2) return 0;
    
    int& ret = cache2[width];
    if(ret != -1) return ret;
    ret = asymmetric2(width-2) % MOD // 대칭인 경우 1
    ret = (ret + asymmetric2(width-4)) % MOD // 대칭인 경우 2
    ret = (ret + tiling(width-3)) % MOD // 비대칭인 경우 1
    ret = (ret + tiling(width-3)) % MOD // 비대칭인 경우 2
    return ret;
}
// 시간복잡도는 O(n)

// --------------- 스캐폴딩으로 테스트하기
// 이 문제는 입력을 생성하기 쉽고, 느리지만 정답임을 확실히 알 수 있는 알고리즘(모든 타일링 방법을 만들어보고 대칭인지 확인하기)이 존재하기 때문에
// 스캐폴딩을 통해 테스트하기 아주 적절한 문제이다.
// 비록 느린 알고리즘이라 해도 1부터 20이하의 입력정도는 쉽게 계산할 수 있기떄문에, 모두 계산해보면 더욱 확실해짐.
