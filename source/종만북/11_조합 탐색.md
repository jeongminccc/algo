# 조합 탐색
## 도입
지금까지 다룬 동적 계획법이나 분할 정복 등의 디자인 패러다임은 적절히 적용될 때는 매우 유용하지만, 모든 문제에 적용할 수 는 없다. 적절한 분할 방법이 없는 문제를 분할 정복으로 풀 수도 없고, 중복되는 부분 문제가 전혀 없거나 메모리를 너무 많이 사용하는 문제에 동적 계획법을 쓸 수도 없다. 이럴때 우리는 다시 완전 탐색으로 돌아와야 한다.  
  
  6장에서 다룬바와 같이 완전 탐색 알고리즘은 대개 답을 만드는 과정을 여러 개의 선택으로 나눈 뒤, 재귀 호출을 이용해 각각의 선택지를 채워가는 형태로 구현되곤 한다. 이때 부분 답과 완성된 답의 집합을 __탐색 공간(search space)__ 라고 부른다. 외판원 문제에서 탐색 공간의 한 원소는 지금까지 방문한 정점의 목록과 현재 위치로 구성된다.    
  
  완전 탐색은 모든 답을 다 만들어 보면서 문제를 해결하므로, 수행 시간은 탐색 공간의 크기에 직접적으로 비례한다. 그런데 대부분의 문제에서는 탐색 공간의 크기는 기하 급수적으로 증가한다. 따라서 완전 탐색은 문제의 규모가 조금이라도 클 경우 사용하기 어렵다는 문제점이 있다.    

완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘 들을 __조합 탐색(combinatorial search)__ 라고 부른다. 조합 탐색에는 다양한 최적화 기법이 있으며, 이들은 접근 방법은 다르지만 모두 기본적으로 모두 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여 만들어 봐야 할 답의 수를 줄이는 것을 목표로 한다.  

조합 탐색을 최적화 하기 위해 어떤 방법을 사용해야 할지 찾아내는 것은 문제 자체에 대한 깊은 식견을 요구하며, 속도, 정확도, 입력 형태사이의 상충 관계등 모두 고려해야 한다. 이렇게 어려운 문제이기 때문에 조합 탐색에는 딱히 정답이 없다. 여기서 배우는 조합 탐색 최적화 기법들은 크게 두가지로 분류 할 수 있다.    

- __가지치기(pruning)__ 기법은 탐색 과정에서 최적해로 연결될 가능성이 없는 부분들을 잘라낸다. 가지치기의 가장 기초적인 예로, 지금까지 찾아낸 최적해보다 부분해가 이미 더 나빠졌다면 현재 상태를 마저 탐색하지 않고 종료해 버리는 방법이 있다. 외판원 문제를 푸는데, 길이가 10인 경로를 이미 찾아냈다고 하자. 재귀 호출 도중 현재까지 만든 부분 경로의 길이가 이미 10 이상이 되었다면 더이상 탐색하지 않고 탐색을 중단해도 된다. 가지치기 기법을 사용하면 존재하는 답 중의 일부는 아예 만들지 않기 때문에 프로그램의 동작 속도가 빨라진다. 
- 좋은 답을 빨리 찾아내는 기법들은 탐색의 순서를 바꾸거나, 탐색 시작 전에 __탐욕법을 이용해 적당히 좋은 답을 우선 찾아낸다.__  완전 탐색의 경우 답을 어떤 순서로 찾아내건 상관없지만, 가지치기와 함께 사용할 경우 더 좋은 답을 알고 있으면 좀더 일찍 탐색을 중단할 수 있기때문에 탐색의 효율이 좋아진다.


