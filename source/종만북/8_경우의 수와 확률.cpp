//
//  8_경우의 수와 확률.cpp
//  algo
//
//  Created by jm on 2020/08/13.
//  Copyright © 2020 jm. All rights reserved.
//

// DP는 최적화 문제를 풀기 위해 고안되었긴 했지만, 경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용된다.
// 경우의 수 계산 문제는 흔히 재귀적인 특징을 가지고있기 떄문이다(ex 이항계수)

// 오버플로에 유의하기
// 대개 경우의 수를 세는 문제에서 답은 입력의 크기에 대해 지수적으로 증가하기 마련이다. - 그렇지않다면 그냥 완탐쓰면 되므로
// 즉 답이 보통 32비트 정수형보다 크게 나오는 경우가 많다. (그래서 M으로 나눈 나머지 출력하라함)

// ---------------- 타일링 방법의 수 세기 -------------- //

// 먼저 완탐을 이용한 함수를 작성한뒤, 메모이제이션을 이용해 DP로 바꿔보자.
// 맨 왼쪽 세로줄이 어떻게 채워져 있느냐에 따라 나눌 수 있다 (세로한줄 or 두개의 가로타일)
// 이때, 다음의 조건들이 성립함을 알 수 있다.
// - 이 두 가지 분류는 타일링 하는 방법을 모두 포함합니다. -> 모든 방법 포함 (이 조건을 위반시 실제보다 적은 답 출력)
// - 두 가지 분류에 모두 포함되는 타일링 방법은 없습니다.  -> 중복 아님     (이 조건을 위반시 실제보다 많은 답 출력)
// 이 두가지 속성은 경우의 수를 셀때 항상 확인해야 하는 조건이다.

// 부분 문제 정의 : tiling(n) = 2 x n 크기의 사각형을 타일로 덮는 방법을 반환한다.
// 이전의 정보는 들어가있지 않음.
// 세로타일 하나 혹은 가로타일 두개이므로, 즉 tiling(n) = tiling(n-1) + tiling(n-2)가 성립함을 알 수 있다.

// DP code
const int MOD = 1e9 + 7;
int cache[101];
int tiling(int width){
    if(width <= 1) return 1;
    
    int& ret = cache[width];
    if(ret != -1) return ret;
    return ret = (tiling(width-1) + tiling(width-2)) % MOD;
}
// 부분문제수는 O(n)이고, 계산에는 O(1)의 시간이 들기때문에 전체 시간복잡도는 O(n)


// ---------------- 삼각형 위의 최대 경로 개수 세기 -------------- //

// 이전문제에서는 최대경로의 합만 구했고, 경로 자체는 구하지 않았다.
// 이 문제를 해결하기 위해서는 두개의 다른 DP를 해결해야 한다.
// 먼저 바탕이 되는 최적화 문제를 푼 뒤, 각 부분 문제마다 최적해의 개수를 계산하는 DP 알고리즘을 만드는 것이다.
// 먼저 최적화 문제는 앞에서 풀었기 때문에, 최대 합이 기록되어 있는 배열에서, 합이 더 높은 경로로 내려가는 방식의 알고리즘으로
// 최대 경로의 개수를 센다.

int countCache[100][100];
int count(int y, int x){
    if(y == n-1) return 1;
    
    int& ret = countCache[y][x];
    if(ret != -1) return ret;
    ret = 0;
    
    if(count(y+1,x) >= count(y+1,x+1)) ret += count(y+1,x);
    if(count(y+1,x) <= count(y+1,x+1)) ret += count(y+1,x+1);
    return ret;
}


// ---------------- 우물을 기어오르는 달팽이 -------------- //

// 확률과 경우의 수에는 밀접한 관련이 있기 때문에 많은 경우 확률을 계산하는 문제에도 DP를 쓸 수 있다.
// 깊이가 n미터, 달팽이는 비가내리면 2미터, 안내리면 1미터 올라간다. m일간 50%확률로 비가온다고 가정하면 우물끝까지 올라갈 확률은?

// 경우의 수로 확률 계산하기
// 비가 오거나, 오지않거나 둘중 하나이므로 M일간의 조합은 모두 2^m 가지이다.
// 따라서 날씨 조합중 합이 n이상인 조합의 수를 센뒤, 전체 조합의 수로 나누면 확률을 구할 수 있다.

// 완전 탐색 알고리즘
// climb(C') = 지금까지 만든 날씨 조합 C'를 완성해서 원소의 합이 n이상이 되도록 하는 방법의 수
// climb(C') = climb(C' + [1]) + climb(C' + [2]) (C' + [x]는 배열 C'의 맨 뒤에 x를 덧붙인 결과)
// C'에서 우리가 쓰는 정보는 지금까지 C'의 길이와 C'의 원소들의 합 뿐이니 다음과 같이 부분 문제 정의를 바꿀 수 있다.
// climb(days, climbed) = 지금까지 만든 날씨 조합 C'의 크기가 days이고 그 원소들의 합이 climbed일때, C'를 완성해서 원소의 합이 n이상이 되게하는 방법의 수
// 다르게 말하면, 달팽이가 days일 동안 climbed 미터를 기어올라 왔을 때 m일전까지 n미터 이상 기어오를 수 있는 경우의 수를 계산한다.
// 이 부분 문제는 최대 n x m 개의 부분 문제만을 갖기 때문에 수월하게 메모이제이션을 적용할 수 있다.

int n, m;
int cache[MAX_N][2*MAX_N+1];
// 달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할때,
// m일 전까지 n미터를 기어올라갈 수 있는 경우의 수
int climb(int days, int climbed){
    if(days == m) return climbed >= n ? 1 : 0;
    
    int& ret = cache[days][climbed];
    if(ret != -1) return ret;
    return ret = climb(days+1, climbed+1) + climb(days+1, climbed+2);
}


// ---------------- 장마가 찾아왔다 -------------- //

// 장마로 인해 비가 올 확률이 75%로 올라갔다고 하자.
// 그러면 날씨의 조합마다 출현할 확률이 달라질 수 있다.
// 이럴 때는 경우의 수를 계산하지 않고 직접 확률을 계산한다.

// climb2(days, climbed) = 달팽이가 지금까지 days일 동안 climbed미터를 기어올라 왔을때 m일전 까지 n미터 이상 기어올라갈 수 있을 확률
// 앞의 문제와 다른것은 사건이 일어날 확률이 다르다는 것이다.
// climb2(days, climbed) = 0.25 x climb2(days+1, climbed+1) + 0.75 x climb2(days+1, climbed+2);
// 확률을 직접 반환한다는 것이 다른점.


// ---------------- 경우의 수 계산하기 레시피 -------------- //

// 1. 모든 답을 직접 만들어서 세어보는 완전 탐색 알고리즘을 설계한다. 이떄 경우의 수를 제대로 세기 위해서는
// 재귀 호출의 각 단계에서 고르는 각 선택지에 다음과 같은 속성이 성립해야 한다.
// a) 모든 경우는 이 선택지들에 포함됨
// b) 어떤 경우도 두개 이상의 선택지에 포함되지 않음
// 2. 최적화 문제를 해결할 때 처럼 이전 조각에서 결정한 요소들에 대한 입력을 없애거나 변형해서 줄인다. 재귀함수는 앞으로 남아있는 조각들을 고르는 경우의 수만 반환해야함.
// 3. 메모이제이션 사용
