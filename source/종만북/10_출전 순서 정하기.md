# 출전 순서 정하기
## 문제 설명
각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승한다.  
결승전 이틀 전, 상대팀의 출전 순서를 알아냈으며 1:1승부에서는 레이팅이 더 높거나 같으면 승리한다.  
어느 순서로 내보내야 최대 승리를 얻을 수 있는지 구하라.

## 무식하게 풀기
n명의 선수가 있으니 n!개의 답이 있다. 하지만 n이 조금만 커져도 시간이 너무 길어짐.

## 동적 계획법
한국팀의 출전 순서를 맨 앞에서부터 한명씩 정해가기로 하면, 각 선수를 지금까지 순서에 추가했는지를 나타내느 불린값 배열만을 받는 부분 문제를 만들 수 있다.
- order(taken) = 각 한국팀 선수를 이미 순서에 추가했는지의 여부가 taken에 주어질 때, 남은 선수들을 적절히 배치해서 얻을 수 있는 최대 승수

taken에 포함된 true의 수를 세면 이번에 선택할 선수가 상대팀의 어떤 선수와 경기하게 되는지도 알 수 있으니, taken외에 다른 인자는 필요가 없다. 그러면 O(n*2^n)시간의 동적 계획법 알고리즘을 얻을 수 있다.

## 탐욕적 알고리즘의 구상
n이 100이상이라면?? DP보다 빠른 알고리즘을 만들어야 한다.  
> 이렇게 막막할때 그리디 알고리즘을 한번 쯤 떠올려 볼 만 하다.

- 그리디를 설계하는 좋은방법은 간단한 입력 몇개를 손으로 풀어보면서 패턴을 찾는것이다.

맨 앞 경기부터 한명씩 출전할 한국 선수를 정하도록 하자, 상대방을 이길 수 있는 한국 선수가 있는 경우, 그중 가장 레이팅이 낮은 선수를 경기시킨다.  

## 탐욕적 선택 속성 증명
이 방법의 정당성을 증명하기 위해, 우리가 하는 선택을 포함하는 최적해가 존재함을 증명하자.  
각 경기에 대해 이 경기를 질 수 밖에 없는 경우 / 이 경기를 이길 수 있는 경우로 나눠 우리의 선택이 옳다는 것을 보일 것이다.    

__이 경기를 질 수 밖에 없는 경우를 고려해 보자.__  
상대팀 선수가 모든 우리 팀 선수보다 레이팅이 높을 경우, 이 경기는 항상 질 수 밖에없다. 
이 경기에 가장 레이팅이 낮은 선수 A대신 B를 내보내는 최적해가 있다고 가정하자. 최적해에서 이 두 선수의 순서를 바꾸면, 이번 경기는 어차피 질테지만 A를 상대했던 선수 x는 레이팅이 더 높은 선수를 상대하게 된다. 따라서 승수가 더 줄어들 일은 없고, 이 경기에 A를 내보내는 최적해가 존재함을 알게된다.  

__이 경기를 이길 수 있는 경우를 고려해보자.__  
상대팀 선수보다 레이팅이 높거나 같은 우리 선수가 있다면 이 경기를 승리할 수 있다.  
승리할 수 있는 선수 중 레이팅이 가장 낮은 A대신 레이팅이 더 높은 B를 내보내는 최적해가 있다고 가정하자.  
이 최적해에서 A와 B의 위치를 바꿔보자. 이번 경기는 어차피 승리할 테고, A를 상대했던 x는 레이팅이 더 높은 선수를 상대하게 된다. 이 또한 최적해 임을 알 수 있다.  
> 반대로 A보다 레이팅이 더 낮은 선수를 내보내야 할 경우가 있을까?

A대신 레이팅이 더 낮은 C를 내보내는 최적해가 있다고 가정하자. 그러면 이 경기는 이길 수 있지만 지게된다.  
이 최적해에서 A와 C의 위치를 바꾸면 이 경기는 승리로 바뀐다. A가 했던 경기는 C가 대신해서 질 수도 있겠지만, 결과적으로는 최적해이다.  

- 탐욕적 선택 속성을 증명하는 패턴?

이 패턴은 항상 우리가 선택한 방법을 포함하는 최적해가 있음을 증명하기 위해, 우선 우리가 선택한 방법을 포함하지 않는 최적해의 존재를 가정한다.  
그리고 이것을 적절히 조작해 우리가 선택한 방법을 포함하는 최적해를 만들어 낸다. 

## 최적 부분 구조 증명
첫번째 경기에 나갈 선수를 선택하고 나면 남은 선수들을 경기에 배정하는 부분 문제를 얻을 수 있다.  
이때 남은 경기에서도 당연히 최다승을 얻는 것이 좋으니 최적 부분 구조가 자명하게 성립함을 알 수 있다.

## 구현 
아직 출전하지 않은 선수들의 레이팅을 이진 검색 트리인 multiset<int>에 저장한다. 이로 인해 이길 수 있는 가장 레이팅이 낮은 선수를 찾는 작업과 선택한 선수의 레이팅을 삭제하는 작업 등을 모두 O(lgn)에 수행할 수 있다. 따라서 전체 시간 복잡도는 __O(nlgn)__ 이 된다.

```cpp
int order(const vector<int>& russian, const vector<int>& korean){
    int n = russian.size(), wins = 0;
    
    multiset<int> ratings(korean.begin(), korean.end());
    for(int rus = 0; rus < n; ++rus){
        if(*ratings.rbegin() < russian[rus])
            ratings.erase(ratings.begin());
        else{
            ratings.erase(ratings.lower_bound(russian[rus]));
            ++wins;
        }
    }
    return wins;
}
```
## 탐욕적 알고리즘 레시피
1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
2. 각 조각 마다 어떤 우선순위로 선택을 내려야 할지 결정한다. 이에 대한 직관을 얻기 위해서는 예제입력이나 그 외의 작은 입력을 몇 개 손으로 풀어보자.
3. 어떤 방식이 동작할 것 같으면, 두 가지의 속성을 증명해보자.
- a) 탐욕적 선택 속성 : 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보이면 된다. (우리가 선택한 답과 다른 최적해가 존재함을 가정후, 이것을 조작하여 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어 짐)
- b) 최적 부분 구조 : 각 단계에서 항상 최적의 선택만을 했을때 전체 최적해를 구할 수 있는지 여부를 증명하자. (대개 이 속성이 성립하는지 안하는지는 자명하게 알 수 있다.) 
