# 선형 자료 구조
## 동적 배열
일반적으로 배열과 기능이 같지만, 정해진 크기이상 늘릴수 없는 배열과는 달리 동적으로 크기를 늘릴 수 있다는 장점이 있다.  
공통점  

- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다. 

동적 배열만이 가지고 있는 특성  

- 배열의 크기를 변경하는 resize()연산이 가능하다. O(N)
- 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append()연산을 지원한다. O(1)

이와 같은 연산들을 구현하기 위해 동적 배열은 동적으로 할당받은 배열을 사용한다. 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 한다.  
따라서 동적 배열 클래스는 현재 배열의 크기와 동적으로 할당받은 배열을 가리키는 포인터를 다음과 같이 저장하고 있을 것이다.  
```cpp
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```
새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, 이와 같은 방법을 사용하면 resize()연산을 O(N)에 구현한다는 요구조건을 쉽게 만족시킬 수 있다.  문제는 append()연산인데, resize()를 호출하기에는 수행 시간이 너무 길어질 것이 뻔하다.  
해법은 바로 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 두는 것이다. 그리고 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그쪽으로 전부 옮기는 것이다.   

- 할당받은 메모리의 크기를 배열의 용량 (capacity)
- 실제 원소의 수를 배열의 크기 (size)

만약 현재 배열의 크기가 용량보다 작다면 append()연산은 size를 1 늘리고 그 위치에 새 값을 할당하는 것으로 간한히 구현할 수 있다.
```cpp
// append(newValue)의 일부
array[size++] = newValue;
```

이 과정은 당연히 상수 시간에 구현할 수 있다. 문제가 되는 것은 미리 할당해 둔 메모리가 꽉 찼을 때인데, 여기에 append() 연산을 하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 해야한다. (재할당)
```cpp
// 배열 용량이 꽉 찼으면 재할당받는다.
if(size == capacity){
    // 용량을 M만큼 늘린 새 배열을 할당받는다.
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존의 자료를 복사한다.
    for(int i=0; i<size; ++i)
        newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기한다.
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입
array[size++] = newValue;
```
위 코드는 배열이 꽉 찼을 때 미리 정해놓은 M이라는 크기만큼 배열의 용량을 늘려준다. 이 조건문을 거치고 나면 항상 원소를 삽입할 남은 공간이 있다는 것을 보장할 수 있다. 그런데 이 재할당 과정에 드는 시간은 O(N+M)이 된다. 그렇다면, append 연산을 여러번 하다 보면 반드시 이와 같은 재할당 연산을 하게 될 테고, 그럼 그 중 선형 시간이 걸리는 append() 연산이 있다는 말이므로, 결국 느리다는 말 아닌가??

### 동적 배열의 재할당 전략
하지만 append()를 호출할 때마다 항상 선형 시간이 걸리는 것은 아니다. 아주 가끔 일어나는 재할당 과정 때 뿐이다.  
이렇게 호출할 때마다 수행시간이 달라지는 함수의 시간 복잡도는 연산을 아주 여러번 반복하여 수행한 뒤 수행시간의 평균을 내는것이 옳다.(분할 상환 분석)  

