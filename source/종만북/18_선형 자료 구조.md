# 선형 자료 구조
## 동적 배열
일반적으로 배열과 기능이 같지만, 정해진 크기이상 늘릴수 없는 배열과는 달리 동적으로 크기를 늘릴 수 있다는 장점이 있다.  
공통점  

- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다. 

동적 배열만이 가지고 있는 특성  

- 배열의 크기를 변경하는 resize()연산이 가능하다. O(N)
- 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append()연산을 지원한다. O(1)

이와 같은 연산들을 구현하기 위해 동적 배열은 동적으로 할당받은 배열을 사용한다. 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 한다.  
따라서 동적 배열 클래스는 현재 배열의 크기와 동적으로 할당받은 배열을 가리키는 포인터를 다음과 같이 저장하고 있을 것이다.  
```cpp
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```
새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, 이와 같은 방법을 사용하면 resize()연산을 O(N)에 구현한다는 요구조건을 쉽게 만족시킬 수 있다.  문제는 append()연산인데, resize()를 호출하기에는 수행 시간이 너무 길어질 것이 뻔하다.  
해법은 바로 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 두는 것이다. 그리고 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그쪽으로 전부 옮기는 것이다.   

- 할당받은 메모리의 크기를 배열의 용량 (capacity)
- 실제 원소의 수를 배열의 크기 (size)

만약 현재 배열의 크기가 용량보다 작다면 append()연산은 size를 1 늘리고 그 위치에 새 값을 할당하는 것으로 간한히 구현할 수 있다.
```cpp
// append(newValue)의 일부
array[size++] = newValue;
```

이 과정은 당연히 상수 시간에 구현할 수 있다. 문제가 되는 것은 미리 할당해 둔 메모리가 꽉 찼을 때인데, 여기에 append() 연산을 하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 해야한다. (재할당)
```cpp
// 배열 용량이 꽉 찼으면 재할당받는다.
if(size == capacity){
    // 용량을 M만큼 늘린 새 배열을 할당받는다.
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존의 자료를 복사한다.
    for(int i=0; i<size; ++i)
        newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기한다.
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입
array[size++] = newValue;
```
위 코드는 배열이 꽉 찼을 때 미리 정해놓은 M이라는 크기만큼 배열의 용량을 늘려준다. 이 조건문을 거치고 나면 항상 원소를 삽입할 남은 공간이 있다는 것을 보장할 수 있다. 그런데 이 재할당 과정에 드는 시간은 O(N+M)이 된다. 그렇다면, append 연산을 여러번 하다 보면 반드시 이와 같은 재할당 연산을 하게 될 테고, 그럼 그 중 선형 시간이 걸리는 append() 연산이 있다는 말이므로, 결국 느리다는 말 아닌가??

### 동적 배열의 재할당 전략
하지만 append()를 호출할 때마다 항상 선형 시간이 걸리는 것은 아니다. 아주 가끔 일어나는 재할당 과정 때 뿐이다.  
이렇게 호출할 때마다 수행시간이 달라지는 함수의 시간 복잡도는 연산을 아주 여러번 반복하여 수행한 뒤 수행시간의 평균을 내는것이 옳다.(분할 상환 분석)    

재할당 코드 조각에서, 만약 배열의 용량을 한번에 M씩 늘린다면, N번 append() 연산을 할 때 재할당의 수 K = O(N/M)이다. M은 상수이므로 결국 K = O(N)으로, 재할당마다 복사하는 원소의 수는 M, 2M, ... K x M개로 증가 하므로, 전체 복사하는 원소의 수는 ((K+1)*K / 2)*M = O(K^2) = O(N^2)이다. N번의 append() 연산을 하는 데 드는 총 시간이 O(N^2)라면 한번의 append() 연산에 드는 시간은 평균적으로 O(N)이 된다. 따라서 M을 아무리 크게 잡아도 우리는 상수 시간에 append()를 구현할 수 없다.    

상수 시간에 append()를 구현하는 비결은 재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다. 처음에 배열 용량 1에서 시작해서, 꽉차면 2로 늘리고, 그 후엔 다시 4로 늘린다고 하자. 이렇게 할 경우 1만번의 append() 연산시에 일어나는 재할당 시점과 복사의 수는 다음과 같다.

재할당 시점 : 1, 2, 4, 8, .... 2048, 4096, 8192  
새 배열의 크기 : 2, 4, 8, 16, .... 4096, 8192, 16384    

이때 일어나는 복사의 총 수는 1+2+4...+8192 = 16383이다. 배열 크기의 두배도 안된다.   

- 따라서 한번의 append()에 드는 시간은 평균적으로 O(1)이라고 할 수 있다.
- 가장 중요한 것은 배열의 최종크기를 미리 짐작 할 수 있을 때, 동적 배열의 용량을 미리 늘려둠으로써 재할당에 드는 비용을 없애는 것이다.

## 연결 리스트
- 특정 위치에서의 삽입과 삭제를 상수 시간에 할 수 있는 것이 장점. 
- 연속된 메모리에 위치하는 것이 아닌 흩어져있고 포인터로 이어져 있다.

```cpp
struct ListNode {
    int element; // 담고 있는 원소
    ListNode *prev, *next; // 이전노드, 다음 노드의 포인터
};
```

- i번째 노드를 찾는데 드는 시간은 리스트의 길이에 선형 비례

작업 | 동적 배열 | 연결 리스트
- | - | - 
이전 원소 / 다음 원소 찾기 | O(1) | O(1)
맨 뒤에 원소 추가/삭제 | O(1) | O(1)
맨 뒤 이외의 위치에 원소 추가/삭제 | O(N) | O(1)
임의의 위치의 원소 찾기 | O(1) | O(N)
크기 구하기 | O(1) | O(N) or O(1)
