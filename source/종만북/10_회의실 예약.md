# 회의실 예약
그리디가 유용하게 사용되는 문제중 유명한 예로 __활동 선택 문제(activity selection problem)__ 가 있다.  
회사에 회의실이 하나밖에 없는데, n개의 팀이 각각 회의하고 싶은 시간을 제출했을 경우, 최대 몇개를 선택할 수 있는지

## 무식하게 풀기
겹치치 않는 회의들의 집합은 모두 이 문제의 답이라고 할 수 있고, 이때 최적해는 크기가 가장 큰 부분 집합일 것이다.  
모든 집합을 하나하나 만들어 보며 회의들이 겹치지 않는 답들을 걸러내고 그중 가장 큰 부분 집합을 찾아내자.  
집합의 크기가 n일때, 부분집합의 수는 2^n이므로 n이 30만 되어도 시간안에 풀기는 힘들다.  

## 그리디 구상
그리디로 해결하는 방법을 몇가지 떠올릴 수 있다.  
길이가 짧은 회의부터 하나하나 순회하면서 앞의 것들과 겹치지 않는것들을 추가하는 방법도 그중의 하나이다. -> 하지만 옳지 않음.  
이 문제를 해결하는 탐욕적 방법은 길이와 상관없이 __가장 먼저 끝나는 회의__ 부터 선택하는 것이다.
1. 목록 S에 남은 회의 중 가장 일찍 끝나는 회의를 선택.
2. 그 회의와 겹치는 회의들을 S에서 모두 지운다
3. S가 빌때까지 반복

## 정당성 증명 : 탐욕적 선택 속성
탐욕적 알고리즘의 정당성 증명은 많은 경우 일정한 패턴을 가진다. 이 증명 패턴은 그리디가 항상 최적해를 찾아낼 수 있다는 것을 두가지의 속성을 증명함으로써 보인다.  
우리가 처음으로 증명해야 할 속성은 DP처럼 답의 모든 부분을 고려하지 않고 그리디로만 선택하더라도 최적해를 구할 수 있다는 것이다.  
이 속성은 매우 중요하기 때문에, __탐욕적 선택 속성(greedy choice property)__ 라고 부른다. 어떤 알고리즘에 이 속성이 성립 할 경우, 우리가 각 단계에서 그리디로 내리는 선택은 항상 최적해로 가는 길 중 하나이다.
따라서 그리디로 선택을 해서 손해 볼 일이 없다는 것을 알 수 있다.  
우리가 앞에서 제안한 알고리즘의 경우, 탐욕적 선택 속성이 성립한다는 말은 다음 조건이 성립한다는 의미이다.
> 가장 종료 시간이 빠른 회의를 포함하는 최적해가 반드시 존재한다.  
증명 방법은, S의 최적해 중에 S(min)을 포함하지 않는 답이 있다고 했을때, 이 답은 서로 겹치지 않는 회의의 목록인데, 이 목록에서 첫 번째로 개최되는 회의를 지우고 S(min)을 대신 추가해서 새로운 목록을 만들자. 
S(min)은 S에서 가장 일찍 끝나는 회의이기 때문에, 지워진 회의는 S(min)보다 일찍 끝날 수는 없다. 따라서 두번째 회의와 S(min)이 겹치는 일은 없으며, 새로 만든 목록도 최적해 중 하나가 된다. 
> 따라서 항상 S(min)을 포함하는 최적해는 존재한다.  
이와같은 증명은 우리가 가장 일찍 끝나는 회의를 선택해서 최적해를 얻는 것이 불가능해지는 경우는 없음을 보여준다.

## 최적 부분 구조
이렇게 그리디로 선택하는 것이 항상 최적의 답을 줄 수 있다고 해서 증명이 끝난 것은 아니다. 항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 보여야 한다. 이것은 너무 당연해 보이지만, 경우에 따라 성립하지 않는 경우도 있다. 
- 첫 번째 선택을 하고 나서 남는 부분 문제는 최적이 아닌 방법으로 풀어야 하는 경우  
탐욕법의 정당성을 위해 증명해야 할 두 번째 속성은 __최적 부분 구조(optimal substructure)__ 이다. DP를 다룰때 했듯이, 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 보여야 한다.  
하지만 다행히도, 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다. 첫 번째 회의를 잘 선택하고 겹치는 회의를 모두 걸러냈다면, 남은 회의 중에 당연히 최대한 많은 회의를 선택해야 할것이다.

## 구현
목록을 배열에 저장한다 치면 전체 시간 복잡도는 O(n^2)가 되어 시간도 오래 걸리는 편.  
이 알고리즘을 빠르게 구현하는 한 방법은 모든 회의를 종료 시간의 오름차순으로 정렬해 두는것이다.  
- 이와 같이 특정 조건으로 객체들을 정렬해 두면 탐욕법의 구현이 쉬워지는 경우가 많다.
```cpp
int n;
int begin[100], end[100];
int schedule(){
    vector<pair<int,int>> order;
    for(int i=0; i<n; ++i)
        order.push_back({end[i], begin[i]));
    sort(order.begin(), order.end());
    
    int earliest=0, selected=0;
    for(int i=0; i<order.size(); ++i){
        int meetingBegin = order[i].second, meetingEnd = order[i].first;
        if(earliest <= meetingBegin){
            earliest = meetingEnd;
            ++selected;
        }
    }
    return selected;
}
```


