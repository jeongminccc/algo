# 문자열 합치기

## 문제 설명
c에서는 문자 배열로 문자열을 표현하되 \0 (NULL)으로 문자열의 끝을 지정하는데, 이래서는 문자열의 길이를 쉽게 알 수 있는 방법이 없으므로 여러가지 문제가 발생한다.  
이런 문제중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커진다는 것이 있다. 다음에 주어진 함수 strcat()은 문자열 dest뒤에 src를 붙이는 함수인데, 실행 과정에서 반복문을 두 문자열의 길이를 합한 만큼 수행해야 한다. 이 함수를 사용해 두 문자열을 합치는 비용이 두 문자열의 길이의 합이라고 하자.
```cpp
void strcat(char* dest, const char* src){
    // dest의 마지막 위치를 찾는다.
    while(*dest) ++dest;
    // src를 한 글자 씩 dest에 옮겨 붙인다.
    while(*src) *(dest++) = *(src++);
    // 문자열의 끝을 알리는 \0을 추가한다.
    *dest = 0;
}
```
이 함수를 이용해 n개의 문자열을 순서와 상관없이 합쳐서 한개의 문자열로 만들고 싶다.  
순서와 상관없지만 비용이 다르다. ( al, go를 먼저 합치고(4) spot과 합치면(8) 총 12의 비용이 들지만 al, spot먼저(6), go(8)순이면 14의 비용이 필요)  
최소 비용을 찾아야 한다.

## 풀이

### 그림으로 그려보기
직관을 얻는 가장 좋은 방법은 문자열을 합치는 과정을 그림으로 그려보는 것이다.  
트리와 같은 형태로 문자열들을 합치는 과정을 표현할 수 있다.  리프 노드들은 문자열의 크기, 위로 올라가면서 합쳐지는 크기를 기록

### 탐욕적 알고리즘의 구상
이때 합쳐진 결과 문자열의 길이를 원래 입력에 주어졌던 문자열별로 나눌 수 있다.   
이렇게 각 비용을 분해해 보면 한 문자열로 인해 발생하는 총 비용은 이 문자열이 병합되는 횟수에 문자열의 길이를 곱한 것이라는 사실을 알 수 있다.  
따라서 문자열이 길면 길수록 트리의 윗부분, 짧을수록 아래쪽으로 내려가야 한다는 직관을 얻을 수 있다.

### 알고리즘 설계하기
- 탐욕적 알고리즘은 문제의 답을 여러 조각으로 나눠 한 조각마다 한 가지의 선택을 한다.  

이 문제에서는 한 조각마다 두 문자열을 서로 합치는것으로 하자. 문자열 목록에서 두 개를 골라내고, 이들을 합친 뒤 다시 문자열 목록에 추가하는 과정을 반복한다.
앞에서 그렸던 트리로 이야기 하자면, 이것은 트리를 밑에서부터 만들어 나가는 접근이라고 할 수 있다.    
문자열이 길면 길수록 트리의 위쪽으로 가야한다면, 먼저 항상 가장 짧은 두 개의 문자열을 합치는 것이 어떨까 하는 생각을 할 수 있다.

### 정당성 증명
__탐욕적 선택 속성__ : 알고리즘은 매 단계마다 가장 짧은 두 문자열을 합치는 일을 반복한다. 이 선택이 최적해라면, 이 선택을 포함하는 최적해가 반드시 있음을 보여주면 된다. 문제의 최적해가 가장짧은 두 개의 문자열 a와 b를 서로 처음에 합치지 않는 형태라고 가정하자. 이 형태를 변형해서, 항상 a와 b를 처음에 합치는 최적해도 존재함을 보일것이다. 우선 a와 b가 최초로 합쳐지는 문자열을 X라고 하자. 이때  트리에서 원으로 표현된(리프노드)들은 위치를 서로 바꾼다고 해도 트리의 X 윗부분은 변하지 않을것이라는것을 알 수 있다. X의 길이는 항상 일정하기 때문. 그러므로 X까지 문자열을 합치는 데 필요한 비용만을 신경 쓰도록 할 것이다.    

a와 b가 X에서 몇 단계나 떨어져 있나를 비교해 보자.  
1. 거리가 같을 경우 : x와 b의 위치를 서로 바꿔도 답은 변하지 않는다.
2. 거리가 다를 경우 : a,b중 X에 더 가까운 쪽이 더 먼쪽과 합쳐지도록 옮겨간다. 만약 a가 b보다 멀리 떨어져있다면 b와 x(a와같은 위치에있음)의 위치를 바꾼다. x가 병합되는 횟수는 줄고, b가 병합되는 횟수는 그만큼 늘어나는데, x의 길이는 항상 b보다 크기때문에 결과적으로는 항상 이득이거나 같은 비용이 들게 된다.  

이렇게 우리와 다른 선택을 한 최적해가 존재한다면 적절한 조작을 통해 우리가 선택한 답으로 변형할 수 있음을 알 수 있다. 이때 총 비용은 더 커지지 않기 때문에 우리 선택을 포함하는 최적해는 반드시 존재하고, 탐욕적 선택 속성은 성립한다.  

__최적 부분 구조__ : 두 문자열을 합치고 나면 남은 문자열들은 항상 최소 비용을 써서 합치는 것이 이득이므로 성립한다.

### 구현 
우리가 만든 알고리즘은 문자열 길이의 목록을 유지하면서 최소 길이를 골라내고, 새 길이를 추가하는 과정을 반복한다. 이와 같은 동작을 가장 효율적으로 구현해 주는 것이 바로 우선순위 큐이다. __우선순위 큐__ 는 집합에서 가장 작은 원소를 찾거나 새 원소를 추가하는 작업을 모두 O(lgn)에 할 수 있도록 해준다. 
```cpp
int concat(const vector<int>& lengths){
    // 최소 큐를 선언
    priority_queue<int, vector<int>, greater<int>> pq;
    for(int i=0; i<lengths.size(); ++i)
        pq.qush(lengths[i]);
    int ret = 0;
    // 원소가 하나 남은 이상 동안 반복한다
    while(pq.size() > 1){
        // 가장 짧은 문자열 두 개를 찾아서 합치고 큐에 넣는다.
        int min1 = pq.top(); pq.pop();
        int min2 = pq.top(); pq.pop();
        pq.push(min1 + min2);
        ret += min1 + min2;
    }
    return ret;
}
```
concat() 함수 내의 whlie문은 N-1번 실행되고, 그 안에서 수행하는 pq.top()과 pq.push()함수 호출에는 최대 O(lgn)의 시간이 걸리기 때문에 시간복잡도는 O(nlgn)이다.

## 이론적 배경 : 허프만 코드 
Huffman code 알고리즘을 각색한 것이다. 허프만 코드는 가변 길이 인코딩 테이블을 만드는 방법으로 여러 압축 알고리즘에 사용된다.  
__가변 길이 인코딩__ 이란 원문의 각 글자를 서로 길이가 다를 수 있는 비트 패턴으로 바꿈으로써 원문의 길이를 줄이는 방법이다.  
따라서 자주 출현하는 글자는 더 짧은 패턴으로 배당할 필요가 있다. 따라서 같은 형태의 탐욕적 알고리즘으로 허프만 코드를 찾을 수 있다.
