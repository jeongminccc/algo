//
//  8_삼각형 위의 최대 경로.cpp
//  algo
//
//  Created by jm on 2020/07/31.
//  Copyright © 2020 jm. All rights reserved.
//

// 최적화 문제들.
// 최적화 문제들 중 특정 성질이 성립할 경우에는 단순히 메모이제이션을 적용하기 보다 좀 더 효율적으로 동적 계획법을 구현할 수 있다.

// 완전 탐색으로 시작
// 경로를 각 가로줄로 조각 낸 뒤, 각 조각에서 아래로 내려갈지 오른쪽으로 내려갈지를 선택하면서 모든 경로를 만들자.
// 재귀 호출 함수에는 현재 위치와 지금까지 만난 숫자들의 합을 전달.
// pathSum(y,x,sum) = 현재위치가 (y,x)이고, 지금까지 만난 수의 합이 sum일때, 이 경로를 맨 아래줄 까지 연장해서 얻을 수 있는 최대합 반환
// 즉 pathSum(y,x,sum) = max(pathSum(y+1,x,sum+triangle[y][x]), pathSum(y+1,x+1,sum+triangle[y][x])

// 무식하게 메모이제이션 적용하기
// 앞에서 정의한 점화식은 답을 구하기 위해 모든 경로를 다 만들어 봐야한다.
// 가능한 경로의 개수는 삼각형의 가로줄이 하나 늘어날 때마다 두 배씩 늘어나므로, n개의 가로줄이있을ㄱ때 2^n-1이 가능함.
// 즉 n이 20까지는 가능할지모르겠지만, 100이므로 너무 크다.

// 메모이제이션을 적용
#include <bits/stdc++.h>
using namespace std;
#define MAX_NUMBER 1000000
int n, triangle[100][100];
int cache[100][100][MAX_NUMBER*100+1];

int path1(int y, int x, int sum){
    if(y == n-1) return sum + triangle[y][x];
    
    int& ret = cache[y][x][sum];
    if(ret != -1) return ret;
    sum += triangle[y][x];
    return ret = max(path1(y+1, x+1, sum), path1(y+1, x, sum));
}
// 위의 코드의 문제점은, cache 배열이 너무 크다는데에 있다.
// 또 다른 문제는 path1()이 특정 입력에 대해서는 완전 탐색처럼 동작한다는 것이다.
// 서로 다른 경로는 합도 항상 다르므로, 똑같은 (y,x)위치까지 내려왔다고 해도 경로마다 다 다른 합을 가지니 같은 계산을 두번 할 일이 없게되므로 사실상 완탐임.

// 해결 -> 재귀 함수의 입력을 나누어서 받자.
// 1. y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 즉 앞으로 풀어야 할 조각들에 대한 정보를 주는 입력들이다.
// 2. sum은 지금까지 어떤 경로로 도달하였는가에 대한것. 즉 지감까지 풀었던 조각들에 대한 정보를 주는 입력이다.

// 메모이제이션 적용2
int cache2[100][100];

int path2(int y, int x){
    if(y == n-1) return triangle[y][x];
    
    int& ret = cache2[y][x];
    if(ret != -1) return ret;
    return ret = max(cache2[y+1][x], cache2[y+1][x+1]) + triangle[y][x];
}

// 여기서 동작속도를 최적화 할 수 있었던 이유는 sum이라는 정보가 문제를 해결하는데 아무 상관이 없었다는 사실이다.
// 즉, 지금까지 어떤 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관없다는 뜻이다. -> 이게 중요! - 최적 부분 구조가 성립하도록 만드는 것.
// 이것은 효율적인 DP를 적용하기 위해 아주 중요한 조건이다. 최적 부분 구조라는 이름을 붙여 DP의 중요요소로 꼽을 정도.
// 최적 부분 구조는 어떤 문제와 분할 방식에 성립하는 조건이다. 각 부분문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을경우 이 조건이 성립한다고한다.
// 삼각형 문제에서는 어느쪽으로 내려갈지의 선택에 따라 두 개의 부분 문제로 문제를 분할할 수 있었다.
// 이떄 지금까지의 선택과 상관없이 각 부분 문제를 최적으로 풀기만 하면 전체 문제의 최적해도 알 수 있으므로, 최적 부분 구조가 성립함을 알 수 있다.

// 다른 예로 서울에서 부산까지 가는 최단경로를 구할떄, 대전을 지난다고 가정해보자.
// 이떄 서울-대전, 대전-부산의 최단 경로를 찾아서 이으면 최단경로를 찾을수 있을것이다. 이러한것이 최적 부분 구조를 갖는다고 할 수 있다.

// 반면 더 작은 문제의 최적해만으로는 전체 문제의 최적해를 구할 수 없다면 최적 부분 구조가 존재하지 않는다.
// 서울에서 부산으로 향하는데 고속도로의 통행료 합이 3만원을 초과하지 않는 최단 경로를 찾고싶다고 할때,
// 대전 - 부산 경로 A : 2시간, 1만원
//          경로 B : 1시간, 2만원
// 이 경우 어느 쪽을 선택해햐 할지는 서울-대전 구간의 통행료에 따라 결정이 된다.
// 즉 최적 부분 구조가 존재하지 않는다.
