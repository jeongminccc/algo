# 크리스마스 인형
## 문제
크리스마스를 맞이하여 산타 할아버지는 전세계의 착한 어린이 K명에게 인형을 사주려고 한다. 산타 할아버지는 인형을 구입하기 위해서 유명한 인형가게인 "놀이터"에 찾아갔다. 놀이터에는 N개의 인형 상자가 한 줄로 진열되어 있고, 각 인형 상자에는 한 개 이상의 인형이 들어 있다. 그리고 놀이터에서는 주문의 편의성을 위해 각 상자에 번호를 붙여 놓았고, 주문은 "H번 상자부터 T번 상자까지 다 주세요."라고만 할 수 있다. (H ≤ T)

산타 할아버지는 한 번 주문할 때마다, 주문한 상자에 있는 인형들을 모두 꺼내서 각각을 K명에게 정확히 같은 수만큼 나누어 주고, 남는 인형이 없도록 한다.

한 번 주문할 수 있다면, 가능한 주문 방법은 몇 가지인가?
여러 번 주문할 수 있다면, 주문이 겹치지 않게 최대 몇 번 주문할 수 있는가? (주문이 겹친다는 것은 어떤 두 주문에 같은 번호의 인형 상자가 포함되는 것을 말한다.)

첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. ( T ≤ 60 )

각 테스트 케이스의 첫 번째 줄에는 인형 상자의 개수 N과 어린이의 수 K가 주어진다.(1 ≤ N, K ≤ 100000)

두 번째 줄에는 1번 인형 상자부터 N번 인형 상자까지 각 인형 상자에 들어 있는 인형의 개수 Di가 주어진다. ( 1 ≤ i ≤ N, 1 ≤ Di ≤ 100000 )

## 구입할 수 있는 방법의 수 계산하기
H번째부터 T번째 상자까지를 주문했을 때 K명의 어린이에게 모두 나눠 줄 수 있다는 말은 항상 psum[H-1] % K = psum[T] % K라는 뜻이다.  
따라서 psum[]의 각 원소를 모두 같은 것끼리 모은 뒤 두개를 선택하자.  

## 겹치지 않고 구입할 수 있는 최대 횟수 계산
서로 겹치지 않는 부분 구간을 가장 많이 골라내는 함수를 다음과 같이 정의하자.  

- maxBuys(i) = 0번 상자부터 i번 상자까지의 범위 내에서 서로 겹치지 않고 구매할 수 있는 부분 구간의 최대 수  

## 구현
구현을 더 간단하게 할 수 있는 입력의 변형이 있다.  
psum[]의 첫번째 원소 이전에 0을 하나 추가로 집어넣으면, psum[i] = psum[j-1]인지를 확인할 때 j=0인 예외에 대해 신경 쓰지 않아도 되기 때문에 구현이 훨씬 간단해 진다.  

```cpp
// D[]의 부분 합 배열 psum[]과 k가 주어질 때, 몇 가지 방법으로 살 수 있는지 반환한다.
// psum[]의 첫 번째 원소 전에 0을 삽입했다고 가정한다.
int waysToBuy(const vector<int>& psum, int k){
    const int MOD = 20091101;
    int ret = 0;
    // psum[]의 각 값을 몇번이나 본적 있는지 기록한다.
    vector<long long> count(k,0);
    for(int i=0; i<psum.size(); ++i)
        count[psum[i]]++;
    // 두번 이상 본적 있다면 이 값중 두개를 선택하는 방법의 수를 더한다
    for(int i=0; i<k; ++i)
        if(count[i] >= 2)
            ret = (ret + ((count[i] * count[i] - 1)) / 2) % MOD;
    return ret;
}

// D[]의 부분 합 배열 psum[]과 k가 주어질 때, 겹치지 않게 몇번이나 살 수 있는지 반환한다.
// psum[]의 첫번째 원소전에 0을 삽입했다고 가정
int maxBuys(const vector<int>& psum, int k){
    // ret[i] = 첫번째 상자부터 i번째 상자까지 고려했을 때 살 수 있는 최대 횟수
    vector<int> ret(psum.size(), 0);
    // prev[s] = psum[]이 s였던 마지막 위치
    vector<int> prev(k, -1);
    for(int i=0; i<psum.size(); ++i){
        // i번째 상잘르 아예 고려하지 않는 경우
        if(i > 0)
            ret[i] = ret[i-1];
        else
            ret[i] = 0;
            // psum[i]를 전에도 본 적 있으면, prev[psum[i]] + 1부터 여기까지 쭉 사본다.
        int loc = prev[psum[i]];
        if(loc != -1) ret[i] = max(ret[i], ret[loc] + 1);
        // prev[]에 현재 위치를 기록
        prev[psum[i]] = i;
    }
    return ret.back();
}
```

waysToBuy()는 첫 번째 문제의 답을 구하기 위해 psum[]의 각 값의 출현 빈도수를 계산한 후, 각 빈도 f에 대해 합을 계산한다.  
maxBuys()는 앞에서 설명한 완탐 알고리즘을 DP로 구현한다.  

- ret[i] = max(ret[i-1], ret[prev[psum[i]]] + 1)  

두 함수의 시간복잡도는 모두 O(N+K) 이므로 시간내에 수행 가능 하다.
